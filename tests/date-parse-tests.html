<html>

<head>
  <title>Date Parse Tests</title>
  <meta charset="UTF-8">
  <script src="../addon/utils/dateutils.js"></script>
</head>

<body>
  <h1>Date Parse tests</h1>
  <textarea cols="140" rows="20" id="data">
{
    "2010-10-20T20:10:00+0300":                                             "2010-10-20T20:10:00+0300",
    "2010-10-20T20:10:00+03:00":                                            "2010-10-20T20:10:00+0300",
    "October 31st 2010|Oct 31 at 10:00 AM - 10:30 PM ¬∑ CST|null":           "2010-10-31T10:00:00-0600|2010-10-31T22:30:00-0600",
    "Friday, April 17, 2020|4:00 PM":                                       "2020-04-17T16:00:00+0000",
    "Friday, April 17, 2020|4:00 PM|europe/london":                         "2020-04-17T16:00:00+0100",
    "Friday, April 17, 2020|4:00 PM|europe/zurich":                         "2020-04-17T16:00:00+0200",
    "Onsdag den 17. februar 2021|19.00|Etc/UCT":                            "2021-02-17T19:00:00+0000",
    "–°–µ—Ä–µ–¥–∞, 1 –∫–≤—ñ—Ç–Ω—è 2020 —Ä.|–ö–í–Ü 1 —Å—Ä 12:00|America/Chicago":              "2020-04-01T17:00:00.000Z",
    "Mittwoch, 1. M√§rz 2020|Mi 12:00|America/Chicago":                      "2020-03-01T18:00:00.000Z",
    "Mittwoch, 1. April 2020|APR 1 Mi 12:00|America/Chicago":               "2020-04-01T17:00:00.000Z",
    "Mardi 31 mars 2020|MAR 31 mar 06:00|Etc/UCT":                          "2020-03-31T06:00:00.000Z",    
    "Mercredi 1 avril 2020|AVR 1 mer 18:30|America/Chicago":                "2020-04-01T23:30:00.000Z",
    "Fredag 11. desember 2020|DES. 11. fr. 19:00|Europe/London":            "2020-12-11T19:00:00.000Z",
    "Quarta-feira, 1 de abril de 2020|ABR 1 Qua 12:00|America/Chicago":     "2020-04-01T17:00:00.000Z",
    "2021Âπ¥1Êúà17Êó•Ê∞¥ÊõúÊó•|19:00|europe/london":                               "2021-01-17T19:00:00+0000",
    "2021Âπ¥12Êúà17Êó•Ê∞¥ÊõúÊó•|19:00|europe/london":                              "2021-12-17T19:00:00+0000",
    "–°—Ä–µ–¥–∞, 1 –∞–ø—Ä–µ–ª—è 2020 –≥.|–ê–ü–† 1 –°—Ä 18:30|America/Chicago":               "2020-04-01T23:30:00.000Z",
    "‚Äè◊ô◊ï◊ù ◊©◊ú◊ô◊©◊ô, 31 ◊ë◊û◊®◊• 2020‚Äè|◊û◊®◊• 31 ◊©◊ú◊ô◊©◊ô 6:00|Etc/UCT":                  "2020-03-31T06:00:00.000Z",
    "2020Âπ¥3Êúà30Êó•Âë®‰∏Ä|3 Êúà 30Êó• Âë®‰∏Ä 06:00|Etc/UCT":                        "2020-03-30T06:00:00.000Z",
    "‡§¨‡•Å‡§ß‡§µ‡§æ‡§∞, 1 ‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 2020|‡§Ö‡§™‡•ç‡§∞‡•à‡§≤ 1 ‡§¨‡•Å‡§ß 6:30 ‡§Ö‡§™‡§∞‡§æ‡§π‡•ç‡§®|America/Chicago":              "2020-04-01T23:30:00.000Z",
    "Poniedzia≈Çek, 30 marca 2020|MAR 30 pon. 06:00":                        "2020-03-30T06:00:00.000Z",
    "Oct 30 2020 at 10 AM ‚Äì Oct 31 2020 at 10 PM||Asia/Calcutta":           "2020-10-30T04:30:00.000Z|2020-10-31T16:30:00.000Z",
    "Thursday, September 17, 2020 at 4:30 PM ‚Äì 9 PM||Asia/Calcutta":        "2020-09-17T11:00:00.000Z|2020-09-17T15:30:00.000Z",
    "Tirsdag den 24. marts 2020|06.00-00.00 UTC+01|null":                   "2020-03-24T05:00:00.000Z|2020-03-24T23:00:00.000Z",
    "L√∂rdag 2 januari 2021|14:30 - 17:15 UTC":                              "2021-01-02T14:30:00.000Z|2021-01-02T17:15:00.000Z",
    "Viernes, 9 de abril de 2021|19:30 - 22:00 UTC+02|europe/madrid":       "2021-04-09T19:30:00+0200|2021-04-09T22:00:00+0200",
    "2020-06-19T15:00:00+01:00 to 2020-06-20T14:30:00+01:00":               "2020-06-19T15:00:00+0100|2020-06-20T14:30:00+0100",
    "Thursday, December 31, 2020 at 9:00 PM ‚Äì 3:00 AM EST||America/New_York":"2021-01-01T02:00:00.000Z|2021-01-01T08:00:00.000Z",
    "Today at 5 PM - 8 PM||Etc/UTC":                                        "todayT17:00:00.000Z|todayT20:00:00.000Z",
    "Tomorrow at 5 PM||Etc/UTC":                                            "tomorrowT17:00:00.000Z",
    "Monday at 5 PM||Etc/UTC":                                              "mondayT17:00:00.000Z",
    "Tuesday at 5 PM||Etc/UTC":                                             "tuesdayT17:00:00.000Z",
    "Wednesday at 5 PM||Etc/UTC":                                           "wednesdayT17:00:00.000Z",
    "THURSDAY at 5 PM||Etc/UTC":                                            "thursdayT17:00:00.000Z",
    "Friday at 5 PM||Etc/UTC":                                              "fridayT17:00:00.000Z",
    "Saturday at 5 PM||Etc/UTC":                                            "saturdayT17:00:00.000Z",
    "Sunday at 5 PM||Etc/UTC":                                              "sundayT17:00:00.000Z",
    "I dag kl 17.00||Etc/UTC":                                              "todayT17:00:00.000Z",
    "I morgen kl 17.00||Etc/UTC":                                           "tomorrowT17:00:00.000Z",
    "ÊòéÊó• 14:00„Äú18:00||Etc/UTC":                                           "tomorrowT14:00:00.000Z|tomorrowT18:00:00.000Z",
    "–°—É–±–±–æ—Ç–∞, 5 –¥–µ–∫–∞–±—Ä—è 2020 –≥. —Å 20:00 –¥–æ 23:00||Etc/UTC":                 "2020-12-05T20:00:00.000Z|2020-12-05T23:00:00.000Z"
}
        </textarea><br />
  <button onclick="run()">Run</button><br />
  <textarea cols="120" rows=3 id="errors">none :)</textarea><br>
  Month names: <input id="lang" value="en" onchange="getMonthNames()" /><br />

  <textarea id="months"></textarea>
</body>
<script>
  function run() {
    document.querySelector("#errors").value = "running...";
    document.querySelector("#errors").style.borderColor = "green";

    let errors = "";
    let date = null;

    let data_json = document.querySelector("#data").value;
    try {
      data = JSON.parse(data_json);
    } catch (error) {
      document.querySelector("#errors").value = "ü§Æ Can't parse your JSON my dear terminal operator!\n\n" + error;
      return;
    }

    for (let testKey in data) {
      let result = replaceRelativeDate(data[testKey]);
      let test = testKey.split('|');
      let testDate = test[0];
      let testTime = test.length > 1 ? test[1] : null;
      let testTimezone = test.length > 2 ? test[2] == "null" ? null : test[2] : "Etc/UCT";

      try {
        let testResultDate = DateUtils.parseDate(testDate, testTime, testTimezone);
        if (result!==null) {
          let expectedResult = { start: new Date(Date.parse(result.split('|')[0])), end: result.includes('|') ? new Date(Date.parse(result.split('|')[1])) : null };
          if (testResultDate.start == null) errors += '"' + testKey + '" ‚ö†Ô∏è evaluates to null\n\n';
          if (expectedResult.start == null) errors += '"' + result + ' ‚ö†Ô∏è evaluates to null\n\n';
          if (testResultDate.start != null && expectedResult.start != null && expectedResult.start.getTime() != testResultDate.start.getTime()) errors += '"' + testKey + '" ‚ö†Ô∏è ' + ' evaluates to ' + testResultDate.start.toISOString() + ' - expecting ' + expectedResult.start.toISOString() + '\n';
          if (testResultDate.end == null && expectedResult.end != null) errors += '"' + testKey + '" ‚ö†Ô∏è ' + ' end time evaluates to null\n';
          if (testResultDate.end != null && expectedResult.end != null && expectedResult.end.getTime() != testResultDate.end.getTime()) errors += '"' + testKey + '" ‚ö†Ô∏è ' + ' end evaluates to ' + testResultDate.end.toISOString() + ' - expecting ' + expectedResult.end.toISOString() + '\n';
        } else {
          if (testResultDate.start !== null) errors += '"' + testKey + '" ‚ö†Ô∏è should evaluate to null\n\n';
        }
      } catch (error) {
        errors += `"${testKey}": "${result}" ‚ùå ${error} (line ${error.lineNumber}, ${error.fileName.substring(error.fileName.lastIndexOf('/') + 1)}\n\n`;
      }
    }
    if (errors) {
      document.querySelector("#errors").value = errors;
      document.querySelector("#errors").style.borderColor = "red";
    } else {
      document.querySelector("#errors").value = "üëç All tests passed without error";
    }
  }
  run();
  getMonthNames();

  function getMonthNames() {
    var lang = document.querySelector("#lang").value
    var format = new Intl.DateTimeFormat(lang, { month: 'long' })
    var months = []
    for (var month = 0; month < 12; month++) {
      var testDate = new Date(Date.UTC(2000, month, 1, 0, 0, 0));
      months.push(format.format(testDate))
    }
    document.querySelector("#months").value = months.join('\n');
  }

  function replaceRelativeDate(dateString) {
    let now = new Date(), then = new Date(), wordMatch

    const relativeMap = {
      "today": 0,
      "tomorrow": 1,
      "sunday": 0 - now.getDay(),
      "monday": 1 - now.getDay(),
      "tuesday": 2 - now.getDay(),
      "wednesday": 3 - now.getDay(),
      "thursday": 4 - now.getDay(),
      "friday": 5 - now.getDay(),
      "saturday": 6 - now.getDay(),
    }

    for (key in relativeMap) {
      if (dateString.includes(key)) {
        let daysAhead = (relativeMap[key] + 7) % 7
        if (daysAhead === 6) return null; // yesterday's day name is a danger zone, don't go there Simba!
        then.setDate(then.getDate() + daysAhead)
        let pad = (i) => { return i < 10 ? "0"+i : i }
        let timeStr = `${then.getFullYear()}-${pad(then.getMonth()+1)}-${pad(then.getDate())}`
        dateString = dateString.replaceAll((new RegExp(key, "ig")), timeStr)
      }
    }

    return dateString;
  }
</script>

</html>